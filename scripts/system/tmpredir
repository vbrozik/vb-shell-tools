#!/bin/bash

# tmpredir

# A script implementing similar functionality as the zsh =(command) operator.
# Instead of the <(command) operator this function creates a temporary file
# containing the output of the command and supplies the path to the main command
# as an argument. The temporary file is deleted after the main command exits.

# TODO:
# * If no -- is given, assume all pipe-files and - are inputs and the first executable
#   non-pipe file argument is the main command.

set -euo pipefail

# Array to store temporary file paths
declare -a temp_files=()

# Cleanup function to remove all temporary files
cleanup() {
    for temp_file in "${temp_files[@]}"; do
        if [[ -f "$temp_file" ]]; then
            rm -f "$temp_file"
        fi
    done
}

# Register cleanup trap
trap cleanup EXIT

# Display usage information
usage() {
    cat <<EOF
Usage: ${0##*/} [OPTIONS] [input_file1 input_file2 ...] -- main_command [args...]

Emulates zsh's =(command) process substitution by capturing command outputs
into temporary files, passing their paths to a main command, and cleaning up.

Arguments:
    input_fileX     Input files or process substitutions <(command)
                    Use - to read from stdin as an input file.
                    If none provided, reads from stdin as %1.
    --              Separator between inputs and main command
    main_command    Command to execute with substituted file paths
    args            Arguments to main command; use %1, %2, etc. as placeholders
                    for the corresponding input file paths.
                    If no placeholders are used, temp file paths are appended
                    as arguments to the main command.

Options:
    -h, --help      Show this help message and exit

Examples:
    # Compare output of two commands using diff
    ${0##*/} <(ls /dir1) <(ls /dir2) -- diff %1 %2

    # Inspect file type of command output
    ${0##*/} <(echo "hello") -- file %1

    # Multiple uses of same temp file
    ${0##*/} <(date) -- sh -c 'cat %1; wc -c %1'

    # Escape literal % with %%
    ${0##*/} <(echo "50") -- sh -c 'cat %1; echo "%%"'

    # Read from stdin when no input files given
    echo "hello world" | ${0##*/} -- wc -w %1

    # Without placeholders, temp files are appended as arguments
    ${0##*/} <(echo "file1") <(echo "file2") -- cat
EOF
}

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --|-)
            break
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Collect input files until we hit --
declare -a input_files=()
while [[ $# -gt 0 && "$1" != "--" ]]; do
    if [[ "$1" == - ]]; then
        input_files+=("/dev/stdin")
    else
        input_files+=("$1")
    fi
    shift
done

# Skip the -- separator
if [[ $# -gt 0 && "$1" == "--" ]]; then
    shift
fi

# If no input files provided, read from stdin
if [[ ${#input_files[@]} -eq 0 ]]; then
    input_files+=("/dev/stdin")
fi

# Remaining arguments are the main command
if [[ $# -eq 0 ]]; then
    echo "Error: No main command specified after --" >&2
    usage >&2
    exit 1
fi

declare -a main_command=("$@")

# Validate that we have input files if placeholders are used
if [[ ${#input_files[@]} -eq 0 ]]; then
    # Check if any placeholders are used in the command
    for arg in "${main_command[@]}"; do
        if [[ "$arg" =~ %[0-9]+ ]]; then
            echo "Error: Placeholder found but no input files provided" >&2
            exit 1
        fi
    done
fi

# Create temporary files from inputs
# Note: stdin must be read sequentially; other files can be read in parallel
declare -a pids=()
declare -a parallel_indices=()
declare -a stdin_indices=()

for i in "${!input_files[@]}"; do
    input="${input_files[$i]}"
    temp_file=$(mktemp /tmp/tmpredir.XXXXXX)
    temp_files+=("$temp_file")

    if [[ "$input" == "/dev/stdin" ]]; then
        stdin_indices+=("$i")
   else
        # Copy regular file content to temp file in background
        cat "$input" > "$temp_file" &
        pids+=($!)
        parallel_indices+=("$i")
    fi
done

# Read stdin sequentially in foreground
# This happens in parallel with the background jobs launched above
for i in "${stdin_indices[@]}"; do
    temp_file="${temp_files[$i]}"
    if ! cat > "$temp_file"; then
        echo "Error: Failed to read stdin input $((i + 1))" >&2
        exit 1
    fi
done

# Wait for all parallel background jobs and check for errors
for j in "${!pids[@]}"; do
    if ! wait "${pids[$j]}"; then
        echo "Error: Failed to read input $((parallel_indices[j] + 1))" >&2
        exit 1
    fi
done

# Substitute placeholders in main command arguments
# Use a unique marker to preserve escaped %% sequences
readonly PERCENT_MARKER='@TMPREDIR_PERCENT_ESCAPE@'

placeholders_used=false
declare -a substituted_command=()
for arg in "${main_command[@]}"; do
    substituted_arg="$arg"
    # First, replace %% with a unique marker
    substituted_arg="${substituted_arg//%%/$PERCENT_MARKER}"
    # Then substitute placeholders %1, %2, etc.
    for i in "${!temp_files[@]}"; do
        placeholder="%$((i + 1))"
        if [[ "$substituted_arg" == *"$placeholder"* ]]; then
            placeholders_used=true
            substituted_arg="${substituted_arg//$placeholder/${temp_files[$i]}}"
        fi
    done
    # Finally, convert marker back to single %
    substituted_arg="${substituted_arg//$PERCENT_MARKER/%}"
    substituted_command+=("$substituted_arg")
done

# If no placeholders were used, append all temp file paths as arguments
if [[ "$placeholders_used" == false ]]; then
    substituted_command+=("${temp_files[@]}")
fi

# Execute the main command
# Note: We cannot use 'exec' here because it replaces the shell process,
# which would prevent the EXIT trap from firing and cleaning up temp files.
"${substituted_command[@]}"
